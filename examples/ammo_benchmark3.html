<html lang="en">
  <head>
    <title>Ammo.js Benchmark</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #61443e;
        font-family:Monospace;
        font-size:13px;
        text-align:center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px; width: 100%;
        padding: 5px;
      }

      a {

        color: #a06851;
      }

    </style>
  </head>
  <body>
    <div id="info">Ammo.js Benchmark</div>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <!-- <script src="../builds/ammo.wasm.js"></script> -->
    <script src="../builds/ammo.js"></script>
    <script src="./js/three/three.min.js"></script>
    <script src="./js/three/GLTFLoader.js"></script>
    <script src="./js/three/OrbitControls.js"></script>
    <script src="./js/three/Detector.js"></script>
    <script src="./js/three/stats.min.js"></script>
    <script src="./js/three/AmmoDebugDrawer.js"></script>

    <script>

    Ammo().then(function(Ammo) {
      // - Global variables -
      var numObjects = 50;

      // Graphics variables
      var container, stats;
      var camera, controls, scene, renderer;
      var textureLoader;
      var clock = new THREE.Clock();

      // Physics variables
      var gravityConstant = -9.8;
      var collisionConfiguration;
      var dispatcher;
      var broadphase;
      var solver;
      var physicsWorld;
      var rigidBodies = [];
      var margin = 0.05;
      var transformAux1 = new Ammo.btTransform();

      var time = 0;

      // Loader variables
      var loader = new THREE.GLTFLoader();
      var modelScale = 5;
      var modelRootScale;
      var model;
      var environmentScale = 1;
      var environmentRootScale;
      var environment;
      var collision;
      var hullShape;
      var bvhTriMesh;

      // - Main code -

      init();
      animate();

      // - Functions -

      function init() {

        initGraphics();

        initPhysics();

        initDebug();

        initLoader();

        // createObjects();

        // startLoop();

      }

      function initGraphics() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.001, 2000 );

        scene = new THREE.Scene();

        // camera.position.x = -12;
        // camera.position.y = 7;
        // camera.position.z =  4;
        camera.position.x = 3.0848581623158915;
        camera.position.y = 8.60097889022121;
        camera.position.z = 3.6373923976973987;

        // setInterval(() => {
        //   console.log(camera.position)
        // }, 1000);

        controls = new THREE.OrbitControls( camera );
        controls.target.y = 2;

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;

        textureLoader = new THREE.TextureLoader();

        var ambientLight = new THREE.AmbientLight( 0x404040 );
        scene.add( ambientLight );

        var light = new THREE.DirectionalLight( 0xffffff, 1 );
        light.position.set( -7, 10, 15 );
        scene.add( light );

        container.innerHTML = 
      "<br /><br /><br /><br /><br />Number of objects: " + numObjects;

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }


      function initDebug() {
        this.debugDrawer = new THREE.AmmoDebugDrawer(scene, physicsWorld);
        this.debugDrawer.enable();
      }

      function initPhysics() {

        // Physics configuration

        collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
        dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
        broadphase = new Ammo.btDbvtBroadphase();
        solver = new Ammo.btSequentialImpulseConstraintSolver();
        physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration);
        physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
      }

      function initLoader() {

        loader.load('./models/DuckyCombinedMesh.glb', ( gltf ) => { 
          var root = gltf.scene.children[0].children[0];
          model = root.children[0];
          collision = root.children[1];

          modelRootScale = root.scale;

          //moving this after instantiating btConvexHullShape breaks things??
          var vec3 = new Ammo.btVector3(); 
          var originalHull = new Ammo.btConvexHullShape();
          originalHull.setMargin(0);
          var positions = model.geometry.attributes.position.array;
          for (var i = 0; i < positions.length; i+=3) {
            vec3.setValue( positions[i], positions[i+1], positions[i+2] );
            originalHull.addPoint(vec3, i == positions.length - 3);
          }

          var shapeHull = new Ammo.btShapeHull(originalHull);
          shapeHull.buildHull(0);

          hullShape = new Ammo.btConvexHullShape(Ammo.getPointer(shapeHull.getVertexPointer()), shapeHull.numVertices());
          // hullShape = originalHull;
          hullShape.setLocalScaling(new Ammo.btVector3(modelRootScale.x * modelScale, modelRootScale.y * modelScale, modelRootScale.z * modelScale));
          hullShape.initializePolyhedralFeatures(0);

          loader.load('./models/Atrium.glb', ( gltf ) => {
            environment = gltf.scene.children[0];
            environmentRootScale = environment.scale;
            var a = new Ammo.btVector3();
            var b = new Ammo.btVector3();
            var c = new Ammo.btVector3();
            var triMesh = new Ammo.btTriangleMesh(true, false);

            for (var i = 0; i < environment.children.length; i++) {
              var mesh = environment.children[i];
              if(mesh.type == "Mesh") {
                mesh.updateMatrixWorld();
                var geometry = mesh.geometry.toNonIndexed();
                geometry.applyMatrix( mesh.matrixWorld );
                var positions = geometry.attributes.position.array;
                for (var j = 0; j < positions.length; j+=9) {
                  a.setValue(positions[j], positions[j+1], positions[j+2]);
                  b.setValue(positions[j+3], positions[j+4], positions[j+5]);
                  c.setValue(positions[j+6], positions[j+7], positions[j+8]);
                  triMesh.addTriangle(a, b, c, j == positions.length - 9);
                }
              }
            }
            bvhTriMesh = new Ammo.btBvhTriangleMeshShape(triMesh, true, true);

            createObjects();
            startLoop();
          });
        });
      }

      function createObjects() {

        var pos = new THREE.Vector3();
        var quat = new THREE.Quaternion();

        // Ground
        pos.set( 0, 0, 0 );
        quat.set( 0, 0, 0, 1 );
        // var ground = createBox( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
        createEnvironment(pos, quat);
        // scene.add(environment);

        //objects
        // x = y = z = 0;
        // for (var z = 0; z < 4 * numObjects/100; z++) {
        //   for (var y = 0; y < 5; y++) {
        //     for (var x = 0; x < 5; x++) {
        //       var height = 5 + z * 1;
        //       var width = x - 5 + Math.random() * 0.5;
        //       var depth = y - 5 +Math.random() * 0.5;
        //       pos.set( width, height, depth );
        //       createObject(1, pos, quat );
        //     }
        //   }
        // }

        for (var x = 0; x < numObjects; x++) {
          var height = x + 5;
          var width =  Math.random() * 0.5;
          var depth = Math.random() * 0.5;
          pos.set( width, height, depth );
          createObject(1, pos, quat );
        }
      }

      function createBox( sx, sy, sz, mass, pos, quat, material ) {

        var threeObject = new THREE.Mesh( new THREE.BoxGeometry(sx, sy, sz), material );
        var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
        shape.setMargin( margin );

        createRigidBody( threeObject, shape, mass, pos, quat );

        return threeObject;
      }

      function createObject(mass, pos, quat ) {
        var threeObject = model.clone();
        threeObject.scale.set(modelRootScale.x * modelScale, modelRootScale.y * modelScale, modelRootScale.z * modelScale);
        createRigidBody( threeObject, hullShape, mass, pos, quat );

        return threeObject;
      }

      function createEnvironment(pos, quat ) {
        // threeObject.scale.set(modelRootScale.x * modelScale, modelRootScale.y * modelScale, modelRootScale.z * modelScale);
        createRigidBody( environment, bvhTriMesh, 0, pos, quat );

        return environment;
      }

      function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

        threeObject.position.copy( pos );
        threeObject.quaternion.copy( quat );

        var transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
        transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
        var motionState = new Ammo.btDefaultMotionState( transform );

        var localInertia = new Ammo.btVector3( 0, 0, 0 );

        if (mass > 0)
          physicsShape.calculateLocalInertia( mass, localInertia );

        var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
        var body = new Ammo.btRigidBody( rbInfo );

        threeObject.userData.physicsBody = body;

        scene.add( threeObject );

        if ( mass > 0 ) {
          rigidBodies.push( threeObject );

          // Disable deactivation
          body.setActivationState( 4 );
        }

        physicsWorld.addRigidBody( body );
      }

      function createRandomColor() {
        return Math.floor( Math.random() * ( 1 << 24 ) );
      }

      function startLoop() {
        var index = 0;
        var transform = new Ammo.btTransform();
        var rot = new Ammo.btQuaternion( 0, 0, 0, 1 );
        var pos = new Ammo.btVector3();
        var zero = new Ammo.btVector3();
        window.setTimeout(() => {

          window.setInterval(() => {
            var body = rigidBodies[index].userData.physicsBody;

            // world.removeRigidBody(body);
            // body.setMassProps(0, zero);
            // body.setCollisionFlags(2);
            // body.setActivationState(4);
            // world.addRigidBody(body);

            body.clearForces();
            body.setLinearVelocity(zero);
            body.setAngularVelocity(zero);

            var ms = body.getMotionState();
            // ms.getWorldTransform(transform);
            transform.setRotation( rot );
            var width = Math.random() * 0.5;
            var depth = Math.random() * 0.5;
            pos.setValue(width, 5, depth);
            transform.setOrigin(pos);
            ms.setWorldTransform(transform);
            body.setWorldTransform(transform); 

            index = (index + 1 ) % rigidBodies.length;
          }, 1000);

        }, 5000);
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {

        var deltaTime = clock.getDelta();

        updatePhysics( deltaTime );

        controls.update( deltaTime );

        renderer.render( scene, camera );

        time += deltaTime;

      }

      function updatePhysics( deltaTime ) {

        // Hinge control
        // Step world
        physicsWorld.stepSimulation( deltaTime, 10 );

        // Update rigid bodies
        for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
          var objThree = rigidBodies[ i ];
          var objPhys = objThree.userData.physicsBody;
          var ms = objPhys.getMotionState();
          if ( ms ) {

            ms.getWorldTransform( transformAux1 );
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set( p.x(), p.y(), p.z() );
            objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

          }
        }

        if (this.debugDrawer) this.debugDrawer.update();

      }

    });

    </script>

  </body>
</html>
