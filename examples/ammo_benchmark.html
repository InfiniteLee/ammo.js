<html lang="en">
  <head>
    <title>Ammo.js Benchmark</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #61443e;
        font-family:Monospace;
        font-size:13px;
        text-align:center;

        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        top: 0px; width: 100%;
        padding: 5px;
      }

      a {

        color: #a06851;
      }

    </style>
  </head>
  <body>
    <div id="info">Ammo.js Benchmark</div>
    <div id="container"><br /><br /><br /><br /><br />Loading...</div>

    <!-- <script src="../builds/ammo.wasm.js"></script> -->
    <script src="../builds/ammo.js"></script>
    <script src="./js/three/three.min.js"></script>
    <script src="./js/three/OrbitControls.js"></script>
    <script src="./js/three/Detector.js"></script>
    <script src="./js/three/stats.min.js"></script>

    <script>

    Ammo().then(function(Ammo) {
      // - Global variables -
      var numObjects = 400;

      // Graphics variables
      var container, stats;
      var camera, controls, scene, renderer;
      var textureLoader;
      var clock = new THREE.Clock();

      // Physics variables
      var gravityConstant = -9.8;
      var collisionConfiguration;
      var dispatcher;
      var broadphase;
      var solver;
      var physicsWorld;
      var rigidBodies = [];
      var margin = 0.05;
      var transformAux1 = new Ammo.btTransform();

      var time = 0;

      // - Main code -

      init();
      animate();


      // - Functions -

      function init() {

        initGraphics();

        initPhysics();

        createObjects();

        startLoop();

      }

      function initGraphics() {

        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.2, 2000 );

        scene = new THREE.Scene();

        camera.position.x = -12;
        camera.position.y = 7;
        camera.position.z =  4;

        controls = new THREE.OrbitControls( camera );
        controls.target.y = 2;

        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0xbfd1e5 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;

        textureLoader = new THREE.TextureLoader();

        var ambientLight = new THREE.AmbientLight( 0x404040 );
        scene.add( ambientLight );

        var light = new THREE.DirectionalLight( 0xffffff, 1 );
        light.position.set( -7, 10, 15 );
        light.castShadow = true;
        var d = 10;
        light.shadow.camera.left = -d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = -d;

        light.shadow.camera.near = 2;
        light.shadow.camera.far = 50;

        light.shadow.mapSize.x = 1024;
        light.shadow.mapSize.y = 1024;
        
        light.shadow.bias = -0.01;

        scene.add( light );

        container.innerHTML = 
      "<br /><br /><br /><br /><br />Number of objects: " + numObjects;

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        //

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function initPhysics() {

        // Physics configuration

        collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
        dispatcher = new Ammo.btCollisionDispatcher( collisionConfiguration );
        broadphase = new Ammo.btDbvtBroadphase();
        solver = new Ammo.btSequentialImpulseConstraintSolver();
        physicsWorld = new Ammo.btDiscreteDynamicsWorld( dispatcher, broadphase, solver, collisionConfiguration);
        physicsWorld.setGravity( new Ammo.btVector3( 0, gravityConstant, 0 ) );
      }

      function createObjects() {

        var pos = new THREE.Vector3();
        var quat = new THREE.Quaternion();

        // Ground
        pos.set( 0, - 0.5, 0 );
        quat.set( 0, 0, 0, 1 );
        var ground = createParalellepiped( 40, 1, 40, 0, pos, quat, new THREE.MeshPhongMaterial( { color: 0xFFFFFF } ) );
        // Boxes
        var boxSize = 0.5;
        var boxMass = 1;
        for (var z = 0; z < 4 * numObjects/100; z++) {
          for (var y = 0; y < 5; y++) {
            for (var x = 0; x < 5; x++) {
              var height = 5 + z * 1;
              var width = x - 5 + Math.random() * 0.5;
              var depth = y - 5 + Math.random() * 0.5;
              pos.set( width, height, depth );
              createParalellepiped( boxSize, boxSize, boxSize, boxMass, pos, quat, createMaterial() );
            }
          }
        }
      }

      function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

        var threeObject = new THREE.Mesh( new THREE.BoxGeometry(sx, sy, sz), material );
        var shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
        shape.setMargin( margin );

        createRigidBody( threeObject, shape, mass, pos, quat );

        return threeObject;

      }

      function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

        threeObject.position.copy( pos );
        threeObject.quaternion.copy( quat );

        var transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
        transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
        var motionState = new Ammo.btDefaultMotionState( transform );

        var localInertia = new Ammo.btVector3( 0, 0, 0 );
        physicsShape.calculateLocalInertia( mass, localInertia );

        var rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
        var body = new Ammo.btRigidBody( rbInfo );

        threeObject.userData.physicsBody = body;

        scene.add( threeObject );

        if ( mass > 0 ) {
          rigidBodies.push( threeObject );

          // Disable deactivation
          body.setActivationState( 4 );
        }

        physicsWorld.addRigidBody( body );

      }

      function createRandomColor() {
        return Math.floor( Math.random() * ( 1 << 24 ) );
      }

      function createMaterial() {
        return new THREE.MeshPhongMaterial( { color: createRandomColor() } );
      }

      function startLoop() {
        var index = 0;
        var transform = new Ammo.btTransform();
        var rot = new Ammo.btQuaternion( 0, 0, 0, 1 );
        var pos = new Ammo.btVector3();
        window.setInterval(() => {
          var i = 0;
          for (var y = 0; y < 5; y++) {
            for (var x = 0; x < 5; x++) {
              var width = x - 5 + Math.random() * 0.5;
              var depth = y - 5 + Math.random() * 0.5;
              var body = rigidBodies[index + i].userData.physicsBody;
              var ms = body.getMotionState();
              ms.getWorldTransform(transform);
              transform.setRotation( rot );
              pos.setValue(width, 5, depth);
              transform.setOrigin(pos);
              ms.setWorldTransform(transform);
              body.setWorldTransform(transform);
              i++;
            }
          }

          index = (index + 25 ) % rigidBodies.length;
        }, 1000);
      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {

        var deltaTime = clock.getDelta();

        updatePhysics( deltaTime );

        controls.update( deltaTime );

        renderer.render( scene, camera );

        time += deltaTime;

      }

      function updatePhysics( deltaTime ) {

        // Hinge control
        // Step world
        physicsWorld.stepSimulation( deltaTime, 10 );

        // Update rigid bodies
        for ( var i = 0, il = rigidBodies.length; i < il; i++ ) {
          var objThree = rigidBodies[ i ];
          var objPhys = objThree.userData.physicsBody;
          var ms = objPhys.getMotionState();
          if ( ms ) {

            ms.getWorldTransform( transformAux1 );
            var p = transformAux1.getOrigin();
            var q = transformAux1.getRotation();
            objThree.position.set( p.x(), p.y(), p.z() );
            objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

          }
        }

      }

    });

    </script>

  </body>
</html>
